# 题纲

## 第一部分-OC基础

1. 一个NSObject对象占用多少内存？

系统分配了16个字节给NSObject对象（通过malloc_size函数获得，创建一个对象，实际分配多少字节）

但NSObject对象内部只使用了8个字节的空间（64bit环境下，可以通过class_getInstanceSize函数获得，class_getInstanceSize创建一个对象，至少需要多少字节）





2. 对象的isa指针是什么？对象的isa指针指向哪里？

instance对象的isa指向class对象

class对象的isa指向meta-class对象

meta-class对象的isa指向基类的meta-class对象



3. OC的类信息存放在哪里？

对象方法、属性、成员变量、协议信息，存放在class对象中

类方法，存放在meta-class对象中

成员变量的具体值，存放在instance对象





4. iOS用什么方式实现对一个对象的KVO？(KVO的本质是什么？)

利用RuntimeAPI动态生成一个子类，并且让instance对象的isa指向这个全新的子类，新生成的子类的super指向原对象。

当修改instance对象的属性时，会调用Foundation的_NSSetXXXValueAndNotify函数

```
willChangeValueForKey:
父类原来的setter，即原对象的setter
didChangeValueForKey:
//didChangeValueForKey内部会触发监听器（Oberser）的监听方法( observeValueForKeyPath:ofObject:change:context:）
```





5. 如何手动触发KVO？

手动调用willChangeValueForKey:和didChangeValueForKey:





6. 直接修改成员变量会触发KVO么？通过KVC修改属性会触发KVO么？

不会，会。





7. KVC的赋值和取值过程是怎样的？原理是什么？

赋值：

1.找对应的赋值方法：setKey-》_setKey

2.找成员变量：_key-》\_isKey-》key-》isKey-

3.未找到setValue: forUndefined

setKey-》_setKey-》accessInstanceVariableDirectly-》\_key-》\_isKey-》key-》isKey-》setValue: forUndefined

取值：

1.找对应的取值方法：getKey-》key-》isKey-》_key

2.找对应的成员变量：_key-》\_ieKey-》key-》isKey

3.找不到valueForUndefinedKey





8. Category的使用场合是什么？





9. Category的实现原理

Category编译之后的底层结构是struct category_t，里面存储着分类的对象方法、类方法、属性、协议信息

在程序运行的时候，runtime会将Category的数据，合并到类信息中（类对象、元类对象中）



10. Category和Class Extension的区别是什么？

Class Extension在编译的时候，它的数据就已经包含在类信息中

Category是在运行时，才会将数据合并到类信息中



11. Category中有load方法吗？load方法是什么时候调用的？load 方法能继承吗？

有load方法

load方法在runtime加载类、分类的时候调用

load方法可以继承，但是一般情况下不会主动去调用load方法，都是让系统自动调用



12. load、initialize方法的区别什么？它们在category中的调用的顺序？以及出现继承时他们之间的调用过程？



Category能否添加成员变量？如果可以，如何给Category添加成员变量？

不能直接给Category添加成员变量，但是可以间接实现Category有成员变量的效果



关联对象及其原理





13. block的原理是怎样的？本质是什么？

封装了函数调用以及调用环境的OC对象



block如何捕获变量，分为哪几种类型



14. __block的作用是什么？有什么使用注意点？



15. block的属性修饰词为什么是copy？哪些情况下会自动copy？使用block有哪些使用注意？

block一旦没有进行copy操作，就不会在堆上

使用注意：循环引用问题



block内部是如何进行内存管理的？如果产生循环引用要怎么处理？





16. block在修改NSMutableArray，需不需要添加__block？





## 第二部分-UI基础



## 第三部分-Runtime

1.讲一下 OC 的消息机制

OC中的方法调用其实都是转成了objc_msgSend函数的调用，给receiver（方法调用者）发送了一条消息（selector方法名）

objc_msgSend底层有3大阶段

消息发送、动态方法解析、消息转发





2.消息机制的每个阶段都做了什么？

消息发送：从cache里面查找-》当前类，及其父类进行查找，查找到，进行缓存-》未找到进入动态方法解析

动态方法解析：调用resolveInstanceMethod或resolveClassMethod，在该方法实现里面用class_addMethod等添加方法。未实现，进入消息转发

消息转发：分两步，第一步找备援者，forwardingTargetForSelector。找到备援者，直接让备援者通过objc_msgSend处理该消息。第二步，完整的消息转发流程，methodSignatureForSelector获取方法签名，然后调用fowardInvocation。

都找不到，doesNotRecognizeSelector。





3.什么是Runtime？平时项目中有用过么？

OC是一门动态性比较强的编程语言，允许很多操作推迟到程序运行时再进行

OC的动态性就是由Runtime来支撑和实现的，Runtime是一套C语言的API，封装了很多动态性相关的函数

平时编写的OC代码，底层都是转换成了Runtime API进行调用



4.具体应用

利用关联对象（AssociatedObject）给分类添加属性

遍历类的所有成员变量（修改textfield的占位文字颜色、字典转模型、自动归档解档）

字典转模型

交换方法实现（交换系统的方法）

利用消息转发机制解决方法找不到的异常问题

......



下面打印结果是什么？为什么会打印出这些？

![image-20190130104154204](http://blog-1251606168.file.myqcloud.com/blog_2018/2019-01-30-024154.png)

左图打印：MJStudent、MJPerson、MJStudent、MJPerson。

右图打印：1，0，0，0



以下代码能不能执行成功？可以执行的话，结果是什么？又怎么解释该结果？

![image-20190130104214081](http://blog-1251606168.file.myqcloud.com/blog_2018/2019-01-30-024214.png)



5.苹果是如何对isa指针进行优化的？具体包含了哪些优化的措施？



6.class_ro_t和class_rw_t分别是什么？有什么区别？



7.方法底层是如何存储的？

method_t结构体，包含SEL name，types编码，IMP imp函数实现地址



8.苹果是如何高效查找方法的？

利用方法缓存，每个对象由个cache_t结构体。

里面存储着方法缓存列表——以SEL name为key，IMP imp为值的一条条。该列表是个哈希表。







## 第四部分-Runloop

讲讲 RunLoop，项目中有用到吗？

作用：保持程序的持续运行、处理APP内的各种事件，节省CPU资源，提高程序性能。



应用：控制线程声明周期（线程保活）、解决NSTimer在滑动时停止工作、监控应用卡顿、性能优化





runloop内部实现逻辑？









runloop和线程的关系？

每条线程对应一个Runloop对象

runloop保存在全局的dictionary对象中，key是线程，value是runloop对象。

线程刚创建没有runloop对象，runloop会在第一次获取时创建它

runloop在线程结束是被销毁

主线程的runloop已经自动创建并获取，子线程默认没有开启runloop





timer 与 runloop 的关系？





程序中添加每3秒响应一次的NSTimer，当拖动tableview时timer可能无法响应要怎么解决？





runloop 是怎么响应用户操作的， 具体流程是什么样的？

当接受一个点击事件，由source1捕获系统事件，再包装成Event分发给source0处理。





说说runloop的几种状态

即将进入Runloop：

即将处理Timer

即将处理Source

即将进入休眠

即将从休眠中唤醒：

即将推出Runloop

各种状态可以通过添加Observer监听。



runloop的mode作用是什么？

mode指runloop运行模式，runloop可以包含多个mode，但启动只能选择一个mode，如果要切换mode，必须先退出当前mode。如果当前runloop没有mode，runloop会马上退出。

mode里面包含了多个事件源：souce0，souce1，timer，observer等。

kCFRunLoopDefaultMode下的状态，主线程一般在该mode下运行，也是app默认mode。

UiTrackingRunLoopmode，界面跟踪mode，用于scrollview追踪触摸滑动，保证界面流程不受其他mode影响。

x

## 第五部分-多线程

你理解的多线程？

作用：提高性能、提升用户体验

两种队列：串行队列、并发队列

两种执行方式：同步、异步





iOS的多线程方案有哪几种？你更倾向于哪一种？

pthread：

NSThread：

GCD：

NSOperation





GCD 的队列类型及其同步异步的处理

串行队列：

并发队列：

主队了：

全局队列：





你在项目中用过 GCD 吗？

队列组：dispatch_group_async、dispatch_group_notify

栅栏函数：





说一下 OperationQueue 和 GCD 的区别，以及各自的优势







多线程有什么安全隐患？线程安全的处理手段有哪些？

隐患：争夺临界资源，数据错乱或数据安全，甚至崩溃。



处理手段：

atomic：保证setter、getter的原子性。但补鞥呢保证使用属性的过程是安全的。

锁：OSSpinLock、os_unfail_lock、pthread_mutex、dispathc_semaphore（信号量）、NSLock、NSRecursiveLock、NSCondition、NSConditionLock、@synchronized

串行队列：dispatch_queue(DISPATCH_SERIAL_QUEUE)







OC你了解的锁有哪些？在你回答基础上进行二次提问；

OSSpinLock：自旋锁，不安全，优先级反转：等待锁的线程优先级较高，会一直占用CPU，导致优先级低的无法释放锁

os_unfail_lock：iOS10才支持，底层看，是休眠而非忙等。

pthread_mutex：互斥锁，等待锁是会进入休眠。

pthread_mutex递归锁：

pthread_mutex条件锁：会初始化一个条件，pthred_cond_wait、pthread_cond_signal、pthread_cond_broadcast

dispathc_semaphore（信号量）: 可以控制访问资源的线程数，会初始化一个信号量的初始值，表示并发访问的最大线程数。dispatch_semaphore_wait，信号量-1，dispatch_semaphore_signal，信号量+1。

NSLock、NSRecursiveLock：对pthread_mutex的封装。

NSCondition：

NSConditionLock：对NSCondition的进一步封装，可以设置具体的条件值。

@synchronized：是对mutex的封装。





追问一：自旋和互斥对比？

追问二：使用以上锁需要注意哪些？

追问三：用C/OC/C++，任选其一，实现自旋或互斥？口述即可！





![image-20190130113811555](http://blog-1251606168.file.myqcloud.com/blog_2018/2019-01-30-033812.png)

打印结果是：1、3

原因

performSelector:withObject:afterDelay:的本质是往Runloop中添加定时器

子线程默认没有启动Runloop





下面打印结果是什么？为什么？

![image-20190130113853214](http://blog-1251606168.file.myqcloud.com/blog_2018/2019-01-30-033853.png)





如何保证读写安全？

策略：

同一时间：只能有一个线程在写，允许多个线程在读，不允许既有写操作，也有读操作。

方案：

pthread_rwlock：读写锁。pthread_rlock\pthread_wlock

异步栅栏函数：dispatch_barrier_async，将写操作放入栅栏函数内。保证写操作前后的读写操作都能完成。





## 第六部分-内存管理



使用CADisplayLink、NSTimer有什么注意点？

避免产生循环引用。

解决方案：

1.NSTimer使用scheduedTimer的block方法创建，并使用weak来引用self。

2.引入代理对象，继承NSProxy。

发送给BFProxy对象的，都会转发给相应对象，所以注意在调用BFProxy类对象时注意最后都会转发给传进来的target。target用weak。打破循环。



iOS 定时器有哪几种？

CADisplayLink：不用设置时间，调用频率和屏幕的刷帧频率一致，60FPS

NSTimer：依赖runloop，如果未加入对应的runloop，或子线程runloop未运行，或者runloop过于繁重未处理，都会导致timer不运行或者不准时。

GCD：dispatch_source_t，设置time，event_hanlder。不依赖runloop，推荐。



介绍下内存的几大区域

从低到高->

保留PAGEZERO

代码段：__TEXT，存放代码即C字符串。

数据段：__DATA，存放全局变量和静态变量，分为初始化好未初始化。

堆：heap，存放对象。

栈：stack，存放函数调用堆栈中的局部变量等。向低地址分配。

内核





讲一下你对 iOS 内存管理的理解

一个技术：引用计数。

两种类型：纯量类型，引用类型（即对象）

三种管理：

1.纯量类型，系统管理。

2.NSTagged Pointer，引用类型，数据小对象类型，引用地址存放Tag+Data。

3.引用计数，针对引用类型，对象isa指针中存放引用计数，并且维护该引用计数。

4.CF对象，需要手动进行管理。

\_\_bridge_transfer

\__bridge

__bridge_retained





描述下你对NSTagged Pointer技术的了解？

64bit后引入的技术，用于优化NSNumber、NSString、NSDate等小对象的存储。

对象地址中存储着Tag+Data数据，Tag表示对象的类型（NSNumber还是NSString，NSNumber中还分为int\double等）或对应的一些属性（如字符串长度等）。Data即对应的值。

objc_msgSend能识别Tagged Pointer，直接从对象地址中提取出数据。





简单说说，引用计数是如何维护的？

1.引用计数的增减

当调用alloc、new、copy、mutabCopy方法返回一个对象，在不需要该对象时，需要进行release或者autorelease。

想拥有某个对象，就让它引用计数+1。不想再拥有，就-1。

在一个对象引用计数为0时，系统会将该对象销毁。



2.引用计数的存储

一般引用计数存放在优化过的isa指针中，19位大小，且存放的是引用计数-1。

如果引用计数过大，就会将isa指针中的一半存放在SideTable的表中。





ARC 都帮我们做了什么？

LLVM + Runtime





weak指针的实现原理







autorelease对象在什么时机会被调用release？

iOS 在主线程的runloop注册了两个Observer，并且做相应操作。

第一个Observer，监听kCFRunLoopEntry，会调用objc_autoreleasePoolPush()

第二个Observer:

监听kCFRunLoopBeforeWaiting，会调用objc_autoreleasePoolPop()、objc_autoreleasePoolPush()

坚挺kCFRunLoopBeforeExit，调用objc_autoreleasePoolPop()



每次Push，都会压入一个哨兵对象，然后每次遇到有对象调用autorelease时，都将该对象加入对应AutoreleasePoolPage中。每次Pop，就会对Page中的对象调用一次release，直到遇到哨兵对象停止。



AutoreleasePoolPage是管理autorelease对象的底层结构，每个page有对应的thread，以及一个指向下一个autorelease对象的地址next。多张page，通过child和parent的指针，串起来组成双向链表。





方法里有局部对象， 出了方法后会立即释放吗？

不一定，局部对象到底什么时候释放，取决于ARC生成对应的release，

1.如果ARC对应生成的是autorelease，那么就不会。这种情况，要依据runloop调度。

2.如果ARC对应生成的是release，就会。实际情况验证是这种情况。







![image-20190130145148626](/Users/wenghengcong/Library/Application Support/typora-user-images/image-20190130145148626.png)





## 第七部分-逆向









## 第八部分-网络









## 第九部分-架构

讲讲 MVC、MVVM、MVP，以及你在项目里具体是怎么写的？





你自己用过哪些设计模式？

单例模式：

代理模式：

组合模式：

工厂模式：

观察者模式：





一般开始做一个项目，你的架构是如何思考的？







## 第十部分-性能

你在项目中是怎么优化内存的？







优化你是从哪几方面着手？









列表卡顿的原因可能有哪些？你平时是怎么优化的？

卡顿的原因：

屏幕成像有CPU和GPU合作的结果：

CPU主要负责计算，对象的创建和销毁、对象属性的调整、文本的计算和排版、图片的格式转码或解码、图像的绘制。

GPU负责纹理的渲染。

屏幕有两个时钟同步信号，垂直同步信号、水平同步信号。

每一次垂直同步信号过来，就会刷新页面，按照60FPS，每隔16ms就有一次刷新。



卡顿优化：

CPU

尽量用轻量级的对象，比如用不到事件处理的地方，可以考虑使用CALayer取代UIView

不要频繁地调用UIView的相关属性，比如frame、bounds、transform等属性，尽量减少不必要的修改

尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性

Autolayout会比直接设置frame消耗更多的CPU资源

图片的size最好刚好跟UIImageView的size保持一致

控制一下线程的最大并发数量

尽量把耗时的操作放到子线程：文本处理（尺寸计算、绘制）、图片处理（解码、绘制）



GPU

尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示

GPU能处理的最大纹理尺寸是4096x4096，一旦超过这个尺寸，就会占用CPU资源进行处理，所以纹理尽量不要超过这个尺寸

尽量减少视图数量和层次

减少透明的视图（alpha<1），不透明的就设置opaque为YES

尽量避免出现离屏渲染





什么是离屏渲染，哪些会导致离屏渲染？

在OpenGL中，GPU有2种渲染方式

On-Screen Rendering：当前屏幕渲染，在当前用于显示的屏幕缓冲区进行渲染操作

Off-Screen Rendering：离屏渲染，在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作

离屏渲染消耗性能的原因

需要创建新的缓冲区

离屏渲染的整个过程，需要多次切换上下文环境，先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕



下列操作会触发离屏渲染

光栅化，layer.shouldRasterize = YES

遮罩，layer.mask

圆角，同时设置layer.masksToBounds = YES、layer.cornerRadius大于0

考虑通过CoreGraphics绘制裁剪圆角，或者叫美工提供圆角图片

阴影，layer.shadowXXX

如果设置了layer.shadowPath就不会产生离屏渲染









如何进行启动优化？

首先分析为什么要进行启动优化，启动太慢了，启动卡住了，才需要进行启动优化。

进行启动时间的测试，Instrument，xcode等进行测试。trick的方式，测试load方法的时间。

启动分为三阶段：dyld加载动态库、runtime初始化、main函数及其之后。

dyld的优化：

减少动态库、合并动态库、清理动态库。

减少Objc的类、分类，Selector的数量，定期清理无用类、方法等。

减少C++虚函数数量。

runtime

用+initialize方法和dispatch_once取代所有的\__attribute__((constructor))、C++静态构造器、ObjC的+load

main函数

在不影响用户体验的前提下，尽可能将一些操作延迟，不要全部都放在finishLaunching方法中

按需加载





如何进行资源瘦身？







如何进行代码瘦身？

1. 和产品、服务端及相关业务方，梳理当前业务及功能。评估灰度、次级功能以及已经下线的功能是否在客户端可以删除。
2. 删除无用代码：https://github.com/pmd/pmd   Appcode
   1. Log代码清理或注释；
   2. 清楚冗余#import https://github.com/dblock/fui
   3. 减少、清理无用变量（全局变量、临时变量），字符串常量；
3. 重用
   1. 视图控件的封装重用，尽量减少“功能全、定制化程度高”的考虑，保证视图或控件“当前可用，下两个版本可扩展”，不用考虑到下面三个版本的事情。；
   2. 分类方法的封装重用；
   3. 宏定义的重用；
4. 代码重构及优化
   1. 减少方法名和类名长度：OC注重见名知义，所以不推荐。
   2. 代码重构，减少重复代码。https://github.com/pmd/pmd
   3. 整合类：将功能相似或者相近的类代码放于同一个类下。
5. RN、Flutter改造。



如何实现组件化？

组件化主要由两种方式：

一种是采用以URL为基础的Router分散式调度，在open URL之前需要先向调度中心进行注册，之后再open时，调度中心会对URL进行解析，包括解析协议、参数以及需要调用的对应代码段。

这种方式下，需要维护一个Router URL表，方便组件提供方和调用方进行协同开发。



第二种是Target-Action方式，即将组件方法封装成对应的target/action，调用中间件Mediator，需要传入target/action，以及Action所需要的参数。

这种方式下，有两种实现target/action的方式，一种是实时编译的，即可以将中间件Mediator创建多个分类，每个分类由组件提供方维护，维护对外的API，调用方只需要引入Mediator，然后通过perforSelector调用。

另外一种就是通过Router来调用，将target/action等封装到URL中，传入参数字典及回调。这种方式也需要维护一个Router表。需要组件提供方和调用方谨慎调用。





## 第十一部分-算法





## 参考

https://hit-alibaba.github.io/interview/

