# KVO、NSNotification、delegate、block的区别

![](https://wiki-1259056568.cos.ap-shanghai.myqcloud.com/ios/20190803142931.png)



# Autolayout

![](https://wiki-1259056568.cos.ap-shanghai.myqcloud.com/ios/20190803150510.png)

```objc
[NSLayoutContraint constraintWithItem:view1
                                                 attribute:NSLayoutAttributeBottom
                                               relatedBy:NSLayoutRelationEqual
                                                    toItem:view2
                                                 attribute:NSLayoutAttributeBottom
                                                multiplier:1.0
                                                 constant:-5]
```



# 优化包括哪些方面

[iOS 保持界面流畅的技巧](https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/#2)



## 内存优化

![](https://wiki-1259056568.cos.ap-shanghai.myqcloud.com/ios/20190803150417.png)

## 启动优化

![](https://wiki-1259056568.cos.ap-shanghai.myqcloud.com/ios/20190804082831.png)

### dyld阶段

针对每一个dylib，都会进行下面操作，最终结果如下图：

- Parse list of dependent dylibs ：分析dylib的依赖关系
- Find requested mach-o ﬁle ：找出对应的mach-o文件
- Open and read start of ﬁle：打开并读取mach-o文件
- Validate mach-o ：校验mach-o文件
- Register code signature：进行代码签名
- Call mmap() for each segment：针对每一个段，调用mmap()，将其映射到虚拟内存

### runtime阶段

runtime所做的事情有

1. 调用map_images进行可执行文件内容的解析和处理
2. 进行各种objc结构的初始化（注册Objc类 、初始化类对象等等）
3. 在load_images中调用call_load_methods，调用所有Class和Category的+load方法
4. 调用C++静态初始化器和__attribute__((constructor))修饰的函数

到此为止，可执行文件和动态库中所有的符号(Class，Protocol，Selector，IMP，…)都已经按格式成功加载到内存中，被runtime 所管理。

### main阶段

1. APP的启动由dyld主导，将可执行文件加载到内存，顺便加载所有依赖的动态库

2. 并由runtime负责加载成objc定义的结构
3. 所有初始化工作结束后，dyld就会调用main函数
4. 接下来就是UIApplicationMain函数，AppDelegate的application:didFinishLaunchingWithOptions:方法

### 优化

![](https://wiki-1259056568.cos.ap-shanghai.myqcloud.com/ios/20190804083302.png)

## 图片优化

图片显示过程：

1. 下载图片
2. 图片处理（裁剪，边框等)
3. 写入磁盘———这里是从网络下载
4. 从磁盘拷贝数据到内核缓冲区
5. 从内核缓冲区复制数据到用户空间(内存级别拷贝)
6. 生成UIImageView，把图像数据赋值给UIImageView
7. 如果图像数据为未解码的PNG/JPG，解码为位图数据（耗cpu较高）
8. CATransaction捕获到UIImageView layer树的变化
9. 主线程Runloop提交CATransaction，开始进行图像渲染
	- 9.1 如果数据没有字节对齐，Core Animation会再拷贝一份数据，进行字节对齐。
	- 9.2 GPU处理位图数据，进行渲染。



- 无损压缩图片
- 异步下载图片
- image解压缩放到子线程
- 使用缓存 (包括内存级别和磁盘级别)
- 存储解压缩后的图片，避免下次从磁盘加载的时候再次解压缩
- 减少内存级别的拷贝 （针对第5点和第9.1点）
- 良好的接口（比如SDWebImage使用category）
- Core Data vs 文件存储
- 图片预下载
- 多个小图拼成一个大图



## 界面优化

![](https://wiki-1259056568.cos.ap-shanghai.myqcloud.com/ios/20190803150237.png)



### 卡顿优化

![](https://wiki-1259056568.cos.ap-shanghai.myqcloud.com/ios/20190804082008.png)

> ## CPU优化
>
> ![](https://wiki-1259056568.cos.ap-shanghai.myqcloud.com/ios/20190804082045.png)
>
> ## GPU优化
>
> ![](https://wiki-1259056568.cos.ap-shanghai.myqcloud.com/ios/20190804082221.png)



### UITableView优化

![](https://wiki-1259056568.cos.ap-shanghai.myqcloud.com/ios/20190803150156.png)

![](https://wiki-1259056568.cos.ap-shanghai.myqcloud.com/ios/20190803150132.png)



## 电量优化

![](https://wiki-1259056568.cos.ap-shanghai.myqcloud.com/ios/20190804082540.png)

![](https://wiki-1259056568.cos.ap-shanghai.myqcloud.com/ios/20190804082601.png)

![](https://wiki-1259056568.cos.ap-shanghai.myqcloud.com/ios/20190804082613.png)



## 安装包优化

### 可执行文件优化

分析

* 利用生产LinkMap分析每个模块的大小
* AppCode

* 编写LLVM插件检测出重复代码、未被调用的代码

1. 功能下线、删除无用代码（AppCode来找）（包括log、无用方法、全局变量、临时变量）

2. 编译器优化

	* Strip Linked Product、Make Strings Read-Only、Symbols Hidden by Default设置为YES

	* 去掉异常支持，Enable C++ Exceptions、Enable Objective-C Exceptions设置为NO， Other C Flags添加-fno-exceptions

3. 重用：抽取部分重复代码-视图控件、方法、宏

4. 重构

5. RN或者Flutter改造

	

### 资源优化

分析

* 按模块进行图片的大小、分类、排查，输出各模块资源占比



优化

* 资源（图片、音频、视频、JSON）
	* 采取无损压缩
	* 去除没有用到的资源
	* 删除无用、重复资源
* assets里的大图移除，因为assets反而会使得大图大小变大。

​	

## 网络优化

![](https://wiki-1259056568.cos.ap-shanghai.myqcloud.com/ios/20190803150223.png)



​	

# 假如B继承自A，A有一个_a的私有变量，B是否能访问到\_a。KVC是否能访问。

> B不能直接访问到_a，但是可以通过KVC访问
>
> NSString *tmp = [self valueForKey:@"_a"];



# 算法：twoSum

一个数组中，某个和的下标。

> 循环
>
> ```java
>  public int[] twoSum(int[] nums, int target) {
>         for (int i = 0; i < nums.length; i++) {
>             for (int j = i + 1; j < nums.length; j++) {
>                 if (nums[j] == target - nums[i]) {
>                     return new int[] { i, j };
>                 }
>             }
>         }
>         throw new IllegalArgumentException("No two sum solution");
> }
> ```
>
> 哈希表
>
> ```java
>  public int[] twoSum(int[] nums, int target) {
>         Map<Integer, Integer> map = new HashMap<>();
>         for (int i = 0; i < nums.length; i++) {
>             map.put(nums[i], i);
>         }
>         for (int i = 0; i < nums.length; i++) {
>             int complement = target - nums[i];
>             if (map.containsKey(complement) && map.get(complement) != i) {
>                 return new int[] { i, map.get(complement) };
>             }
>         }
>         throw new IllegalArgumentException("No two sum solution");
>     }
> ```
>
> 



# 生产者、消费者场景模拟，手写代码。

> ```objc
> @interface ViewController ()
> /**
>  存在银行的钱
>  */
> @property (assign, nonatomic) int money;
> @property (strong, nonatomic) NSLock *moneyLock;
> @end
> 
> @implementation ViewController
> 
> - (void)viewDidLoad {
>     [super viewDidLoad];
>     // Do any additional setup after loading the view.
>     self.moneyLock = [[NSLock alloc] init];
>     [self moneyTest];
> }
> 
> - (void)moneyTest
> {
>     // 初始有存款200
>     self.money = 200;
>     
>     dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
>     dispatch_async(queue, ^{
>         // 存了10次，每次30：+300
>         for (int i = 0; i < 10; i++) {
>             [self __saveMoney];
>         }
>     });
>     
>     dispatch_async(queue, ^{
>         // 取了10次，每次10：-100
>         for (int i = 0; i < 10; i++) {
>             [self __drawMoney];
>         }
>     });
>     
>     // 最后应该为200+300-100=400
> }
> 
> /**
>  存钱：每次存30
>  */
> - (void)__saveMoney
> {
>     [self.moneyLock lock];
>     int oldMoney = self.money;
>     sleep(.2);
>     oldMoney += 30;
>     self.money = oldMoney;
>     
>     NSLog(@"存30，还剩%d元 - %@", self.money, [NSThread currentThread]);
>     [self.moneyLock unlock];
> }
> 
> /**
>  取钱：每次取10
>  */
> - (void)__drawMoney
> {
>     [self.moneyLock lock];
>     int oldMoney = self.money;
>     sleep(.2);
>     oldMoney -= 10;
>     self.money = oldMoney;
>     
>     NSLog(@"取10，还剩%d元 - %@", self.money, [NSThread currentThread]);
>     [self.moneyLock unlock];
> }
> 
> @end
> ```



# GCD具体的实用性。



# @synchronize是什么锁。

> - **synchronized是使用的递归mutex来做同步。**
> - **@synchronized(nil)不起任何作用**
> - 参考两篇文章
> 	- [正确使用多线程同步锁@synchronized()](http://mrpeak.cn/blog/synchronized/)
> 	- [关于 @synchronized，这儿比你想知道的还要多](http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/)

```objc
int objc_sync_enter(id obj)
{
    int result = OBJC_SYNC_SUCCESS;

    if (obj) {
        SyncData* data = id2data(obj, ACQUIRE);
        require_action_string(data != NULL, done, result = OBJC_SYNC_NOT_INITIALIZED, "id2data failed");
	
        result = recursive_mutex_lock(&data->mutex);
        require_noerr_string(result, done, "mutex_lock failed");
    } else {
        // @synchronized(nil) does nothing
        if (DebugNilSync) {
            _objc_inform("NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug");
        }
        objc_sync_nil();
    }

done: 
    return result;
}
```





# 方法交换的实现，手写代码

![](https://wiki-1259056568.cos.ap-shanghai.myqcloud.com/ios/20190803134703.png)

> ```objc
> static dispatch_once_t onceToken;
>     dispatch_once(&onceToken, ^{
>         //case1: 替换实例方法
>         Class selfClass = [self class];
>         //case2: 替换类方法
>         Class selfClass = object_getClass([self class]);
>         
>         //源方法的SEL和Method
>         SEL oriSEL = @selector(viewWillAppear:);
>    			     // Method包含name\types\imp
>         Method oriMethod = class_getInstanceMethod(selfClass, oriSEL);
>         
>         //交换方法的SEL和Method
>         SEL cusSEL = @selector(customViewWillApper:);
>         Method cusMethod = class_getInstanceMethod(selfClass, cusSEL);
>         
>         //先尝试給源方法添加实现，这里是为了避免源方法没有实现的情况
>         BOOL addSucc = class_addMethod(selfClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));
>         if (addSucc) {
>             //添加成功：将源方法的实现替换到交换方法的实现
>             class_replaceMethod(selfClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));
>         }else {
>             //添加失败：说明源方法已经有实现，直接将两个方法的实现交换即可
>             method_exchangeImplementations(oriMethod, cusMethod);
>         }
>     });
> ```



# NSInvocation如何设置NSInteger/int。

1. 取地址符

	> (void)invocation2 {
	>
	> ​	// 1. 根据方法创建签名对象sig
	> ​	NSMethodSignature *sig = [[self class] 	instanceMethodSignatureForSelector:@selector(methodWithArg1:arg2:)];
	>
	> ​	// 2. 根据签名对象创建调用对象invocation
	> ​	NSInvocation *invocation =[NSInvocation invocationWithMethodSignature:sig];
	>
	> ​	// 3. 设置调用对象的相关信息
	> ​	invocation.target = self;
	> ​	invocation.selector = @selector(methodWithArg1:arg2:);
	> ​	NSString *name = @"SJM";
	> ​	int age = 18;
	> ​	// 参数必须从第2个索引开始，因为前两个已经被target和selector使用
	> ​	[invocation setArgument:&name atIndex:2];
	> ​	[invocation setArgument:&age atIndex:3];
	>
	> ​	// 4. 调用方法
	> ​	[invocation invoke];
	>
	> }

# 嵌套Block的weak\strong设置。

  1. 嵌套Block只需要在最外层设置下weak
  2. 在内层每一层强引用一下Block

  

# Block在哪些情况下会copy。

  

# 下面代码在主线程和子线程分别打印什么。

在主线程打印：1、3、2

GCD在全局线程打印：1、3、2

GCD在某一个并发线程也是打印：1、3、2

在NSThead执行也是1、3、2

```objc
- (void)testA
{
				   NSLog(1)
				   [self testB];
				   NSLog(2)
}

- (void)testB
{
	    NSLog(3)
}
```



# 长连接维持心跳包的作用或机制





# iOS APNs的整体机制





# MVVM模式的使用

![](https://wiki-1259056568.cos.ap-shanghai.myqcloud.com/ios/20190803155004.png)





![](https://wiki-1259056568.cos.ap-shanghai.myqcloud.com/ios/20190803164547.png)

M : Model层，负责数据的存储 
V ： viewcontroller，负责管理视图（自定义） 
VM : viewModel，专门负责数据请求、业务逻辑等业务。从 `Model` 中获取 `View` 所需的数据，转换成 `View` 可以展示的数据，并暴露公开的属性和命令供 `View` 进行绑定



1.View可以引用ViewModel，但反过来不行（即：不要在ViewModel中引入#import UIKit.h，任何视图本身的引用都不能放在ViewModel中），ViewModel可以引用Model，但反过来不行。

2.ViewController尽量不要涉及业务逻辑，让ViewModel去做业务逻辑；ViewController 只是一个“中间人”，接收View的事件、调用ViewModel的方法、响应ViewModel的变化；ViewModel 绝不能包含视图View（UIKit.h），否则就跟View产生耦合，不方便复用和测试。



# 动画的基础知识

> UIView动画，核心动画，帧动画，自定义转场动画
>
> ![4408163-9c680e765e6cee63.png](http://api.cocoachina.com/uploads/20170622/1498114752750475.png)

 


# 实现精确的定时器

> 大纲：
>
> - NSTimer
> 	- 循环引用
> 	- 不准时
> 	- 依赖于RunLoop
> 	- 可以取消：invalidate
> - NSObject 的 `(void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay;`
> 	- 本质上也是依赖于RunLoop
> 	- 不准时
> 	- 可以取消：cancelPreviousPerformRequestsWithTarget
> - CADisplayLink
> 	- 不准时的原因
> 	- 循环引用
> 	- 可以取消：
> - GCD 的 `dispatch_after`
> 	- 不准时
> 	- 并不是延迟对应时间后立即执行block块中的操作，而是将任务追加到对应队列中，考虑到队列阻塞等情况，所以这个任务从加入队列到真正执行的时间是不准确的。
> 	- 不能取消：不过有开源方案：https://github.com/Spaceman-Labs/Dispatch-Cancel
> - GCD 的 `dispatch_source_t`
> 	- 高精度
> 	- 准时
> 	- 可以取消
> 	- 参考[Concurrency Programming Guide](https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW2)--Creating a Timer
> - 官方技术文档的做法：[High Precision Timers in iOS / OS X](https://developer.apple.com/library/archive/technotes/tn2169/_index.html)
> 	- 使用mach内核级的函数可以使用mach_absolute_time()获取到CPU的tickcount的计数值，可以通过“mach_timebase_info”函数获取到纳秒级的精确度。然后使用mach_wait_until(unit64_t deadline)函数，直到指定的时间之后，就可以执行指定任务了。





# 什么是光栅化

> ## 概念
>
> 光栅化*是把 GPU 的操作转到 CPU 上，生成位图缓存，直接读取复用。
>
> 光栅化概念：将图转化为一个个栅格组成的图象。
> 光栅化特点：每个元素对应帧缓冲区中的一像素。
>
> 
>
> ## 过程
>
> 光栅化是将几何数据经过一系列变换后最终转换为像素，从而呈现在显示设备上的过程，如下图：
>
> ![](https://img-blog.csdn.net/20130819125657765)
>
> 
>
> 光栅化的本质是坐标变换、几何离散化，如下图：
>
> ![](https://img-blog.csdn.net/20130819125727703)
>
> 
>
> shouldRasterize = YES在其他属性触发离屏渲染的同时，会将光栅化后的内容缓存起来，如果对应的layer及其sublayers没有发生改变，在下一帧的时候可以直接复用。shouldRasterize = YES，这将隐式的创建一个位图，各种阴影遮罩等效果也会保存到位图中并缓存起来，从而减少渲染的频度（不是矢量图）。
>
> 但是光栅化原始图像需要时间，而且还会消耗额外的内存。
>
> 光栅化可以提供很大的性能优势，**但是一定要避免用在内容是动态变化的图层上**，不然它缓存方面的优势就会丧失，而且会让性能变的更糟。
>
> 
>
> ## 使用 Instruments 监测性能
>
> Instruments 的 Core Animation 工具里有检测光栅化是否正确使用的选项：`Color Hits Green and Misses Red`，如果开启了光栅化，渲染结果会被缓存，如果图层是绿色，就表示有渲染缓存可用；如果是红色，就表示无渲染缓存可用，缓存会被重复创建，这就可能导致性能问题。
>
> 



# 离屏渲染是什么，如何避免

> GPU屏幕渲染有以下两种方式：
>
> On-Screen Rendering
> 意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。
>
> Off-Screen Rendering
> 意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。
>
> > 引起离屏渲染的
> >
> > * shouldRasterize（光栅化）
> > * masks（遮罩）
> > * shadows（阴影）
> > * edge antialiasing（抗锯齿）
> > * group opacity（不透明）
> > * 复杂形状设置圆角等
> > * 渐变

![](https://wiki-1259056568.cos.ap-shanghai.myqcloud.com/ios/20190804082318.png)



# 绘制圆角的实现

* layer cornerRadius

	```objc
	 	    self.imageView.layer.cornerRadius = 20.0;
	 	    self.imageView.layer.masksToBounds = YES;
	```

 * CAShapeLayer / UIBezierPath /mask

	```objc
	 	    CAShapeLayer *mask = [CAShapeLayer new];
	     mask.path = [UIBezierPath bezierPathWithRoundedRect:self.imageView.bounds cornerRadius:20].CGPath;
	    	 self.imageView.layer.mask = mask;
	```

	



 * Core Graphic 通过bitmap生产UIImage

	````objc
	- (UIImage *)drawCircleImage
	{
	 	    CGFloat side = MIN(self.size.width, self.size.height);
	 	    UIGraphicsBeginImageContextWithOptions(CGSizeMake(side, side), false, [UIScreen mainScreen].scale);
	 	    CGContextAddPath(UIGraphicsGetCurrentContext(),
	 	                     [UIBezierPath bezierPathWithOvalInRect:CGRectMake(0, 0, side, side)].CGPath);
	 	    CGContextClip(UIGraphicsGetCurrentContext());
	
	 	    CGFloat marginX = -(self.size.width - side) / 2.f;
	 	    CGFloat marginY = -(self.size.height - side) / 2.f;
	 	    [self drawInRect:CGRectMake(marginX, marginY, self.size.width, self.size.height)];
	 	    CGContextDrawPath(UIGraphicsGetCurrentContext(), kCGPathFillStroke);
	 	    UIImage *output = UIGraphicsGetImageFromCurrentImageContext();
	 	    UIGraphicsEndImageContext();
	 	    return output;
	 	}
	````

# load方法的调用顺序

1. 先编译先调用
2. 先调用类load方法，再调用分类的load方法
3. 将load方法按序调用



# 分类方法的调用

1. 后编译的会被调用
2. 原因是：将分类方法倒序插入到类方法的方法列表中



# 有哪些锁





# nil、Nil、NULL、NSNull的区别

nil：指向一个对象的空指针,对objective c id 对象赋空值.

Nil：指向一个类的空指针,表示对类进行赋空值.

NULL：指向其他类型（如：基本类型、C类型）的空指针, 用于对非对象指针赋空值.

NSNull：在集合对象中，表示空值的对象.



# 创建线程的方法

1. NSThread

2. GCD dispatch

3. NSOperation子类，将其加入NSOperationQueue

4. pthread

  

  ![](https://wiki-1259056568.cos.ap-shanghai.myqcloud.com/ios/20190803142806.png)

  ![](https://wiki-1259056568.cos.ap-shanghai.myqcloud.com/ios/20190803135149.png)

![](https://wiki-1259056568.cos.ap-shanghai.myqcloud.com/ios/20190803142640.png)

# frame和boudns的区别

frame指的是：该view相对于父view坐标系统中的位置和大小

bounds：该view在本身坐标系统中的位置和大小




# HTTP协议的主要特点



![](https://wiki-1259056568.cos.ap-shanghai.myqcloud.com/ios/20190803132551.png)



![](https://wiki-1259056568.cos.ap-shanghai.myqcloud.com/ios/20190803134053.png)







# 写出float x与一零值比较的if语句

	if(x>=-0.000001 && x<=0.000001)



# Internet采用哪种网络协议，该协议的层次结构

![](https://wiki-1259056568.cos.ap-shanghai.myqcloud.com/ios/20190803134430.png)

# volatile的含义及场景

![](https://wiki-1259056568.cos.ap-shanghai.myqcloud.com/ios/20190803134635.png)



![](https://wiki-1259056568.cos.ap-shanghai.myqcloud.com/ios/20190803134649.png)



# 将字符串转换为NSDate类型


![](https://wiki-1259056568.cos.ap-shanghai.myqcloud.com/ios/20190803134738.png)



# Crash场景

![](https://wiki-1259056568.cos.ap-shanghai.myqcloud.com/ios/20190803134817.png)

![](https://wiki-1259056568.cos.ap-shanghai.myqcloud.com/ios/20190803134104.png)

# 编译过程

![](https://wiki-1259056568.cos.ap-shanghai.myqcloud.com/ios/20190803135105.png)

# 如何防止反编译

![](https://wiki-1259056568.cos.ap-shanghai.myqcloud.com/ios/20190803141805.png)





# 应用前后台的什么周期

![](https://wiki-1259056568.cos.ap-shanghai.myqcloud.com/ios/20190803142704.png)

![](https://wiki-1259056568.cos.ap-shanghai.myqcloud.com/ios/20190803135122.png)



# static的作用

![](https://wiki-1259056568.cos.ap-shanghai.myqcloud.com/ios/20190803142732.png)



# GCD执行原理

![](https://wiki-1259056568.cos.ap-shanghai.myqcloud.com/ios/20190803135219.png)



# KVO

\-  (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSString *,id> *)change context:(void *)context

被调用。


需要注意的是该处理方法，**被调用时所在的线程：位于被观察的对象属性变化时的线程里。**

比如，在线程3里改变了对象属性，那么，该处理方法就在线程3里被调用；

因此，若在该处理方法里有更新UI的操作时，需要在该方法里，切入主线程再操作；



# 不改变button大小，扩大点击范围

```objc
- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event {
    CGRect rect = [self enlargedRect];
    if (CGRectEqualToRect(rect, self.bounds)) {
        return [super pointInside:point withEvent:event];
    }
    return CGRectContainsPoint(rect, point) ? YES : NO;
}
```

